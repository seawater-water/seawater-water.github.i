<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | 什么是灵魂自由</title><meta name="author" content="Seawater"><meta name="copyright" content="Seawater"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一章 绪论1.2 基本概念和术语1.2.1 数据、数据元素、数据项和数据对象 数据（Data）是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称 例如：多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。   数据元素（Data Element）是数据的基本单位 与数据的关系：是集合的个体   数据项（Data Item）是组成数据元素的，不可分割的最小单位">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://seawater-water.github.io/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="什么是灵魂自由">
<meta property="og:description" content="第一章 绪论1.2 基本概念和术语1.2.1 数据、数据元素、数据项和数据对象 数据（Data）是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称 例如：多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。   数据元素（Data Element）是数据的基本单位 与数据的关系：是集合的个体   数据项（Data Item）是组成数据元素的，不可分割的最小单位">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://seawater-water.github.io/img/default_top_img.jpg">
<meta property="article:published_time" content="2022-09-18T02:41:18.000Z">
<meta property="article:modified_time" content="2023-06-29T10:34:50.163Z">
<meta property="article:author" content="Seawater">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://seawater-water.github.io/img/default_top_img.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://seawater-water.github.io/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-29 18:34:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/ave.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friend Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/default_top_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">什么是灵魂自由</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tag</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Friend Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-18T02:41:18.000Z" title="发表于 2022-09-18 10:41:18">2022-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-29T10:34:50.163Z" title="更新于 2023-06-29 18:34:50">2023-06-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h2><h3 id="1-2-1-数据、数据元素、数据项和数据对象"><a href="#1-2-1-数据、数据元素、数据项和数据对象" class="headerlink" title="1.2.1 数据、数据元素、数据项和数据对象"></a>1.2.1 数据、数据元素、数据项和数据对象</h3><ul>
<li><strong>数据</strong>（Data）是客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号的总称<ul>
<li>例如：多媒体程序处理的图形、图像、声音及动画等通过特殊编码定义后的数据。</li>
</ul>
</li>
<li><strong>数据元素</strong>（Data Element）是数据的<strong>基本单位</strong><ul>
<li>与数据的关系：是集合的<strong>个体</strong></li>
</ul>
</li>
<li><strong>数据项</strong>（Data Item）是组成<strong>数据元素</strong>的，不可分割的<strong>最小单位</strong>。</li>
<li>数据&gt;数据元素&gt;数据项<ul>
<li>例如：学生表&gt;个人纪录&gt;学号，姓名，性别….</li>
</ul>
</li>
<li><strong>数据对象</strong>：<strong>性质相同</strong>的<strong>数据元素</strong>的<strong>集合</strong>，是<strong>数据</strong>的一个子集<ul>
<li>例如：整数的数据对象是集合N&#x3D;{0,+1,-1,+100}</li>
<li>与数据的关系是：集合的<strong>子集</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-2-数据结构"><a href="#1-2-2-数据结构" class="headerlink" title="1.2.2 数据结构"></a>1.2.2 数据结构</h3><ul>
<li><p><strong>数据结构</strong></p>
<ul>
<li><strong>数据元素</strong>不是孤立的，它们之间存在<strong>某种关系</strong>，数据元素相互之间<strong>关系</strong>称为<strong>结构</strong></li>
<li><strong>数据结构</strong>是带<strong>“结构”</strong>的<strong>数据元素</strong>的<strong>集合</strong></li>
<li><strong>数据对象</strong>是<strong>性质相同</strong>的<strong>数据元素</strong>的<strong>集合</strong>，是<strong>数据的子集</strong></li>
</ul>
</li>
<li><p>数据结构包括<strong>逻辑结构</strong>和<strong>存储结构</strong></p>
</li>
<li><p><strong>逻辑结构</strong></p>
<ul>
<li><p>数据元素之间的<strong>逻辑关系</strong>，也称<strong>逻辑结构</strong></p>
</li>
<li><p>两个要素：一是<strong>数据元素</strong>；二是<strong>元素之间的逻辑关系</strong></p>
</li>
<li><p>与数据的<strong>存储</strong>无关，独立于计算机</p>
</li>
<li><p>是从<strong>具体</strong>问题<strong>抽象</strong>出来的<strong>数学模型</strong></p>
</li>
<li><p>划分方法一：可以分为<strong>线性结构</strong>和<strong>非线性结构</strong>：</p>
<ul>
<li>线性结构<ul>
<li><strong>有且只有一个</strong>开始结点和终端结点，所有结点<strong>最多</strong>只有一个直接<strong>前驱</strong>和直接<strong>后继</strong></li>
<li>例如：<strong>线性表</strong>，栈，队列，串</li>
</ul>
</li>
<li>非线性结构<ul>
<li>一个结点可能有<strong>多个</strong>直接<strong>前驱</strong>和<strong>后继</strong></li>
<li>例如：<strong>树</strong>，<strong>图</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>划分方法二：四类<strong>基本逻辑结构</strong>：</p>
<ul>
<li><p>集合结构</p>
<ul>
<li>元素之间没有关系，数据元素之间除了“属于同一个集合”的关系外，别无其他逻辑关系。</li>
</ul>
</li>
<li><p>线性结构</p>
<ul>
<li>元素之间关系是<strong>一对一</strong>的，开始元素和终端元素都是<strong>唯一</strong>的，除此之外，其余元素(结点)都<strong>有且仅有一个</strong>前驱元素和一个后继元素。</li>
</ul>
</li>
<li><p>树形结构</p>
<ul>
<li>元素之间关系是<strong>一对多</strong>的，开始元素<strong>唯一</strong>，终端元素<strong>不唯一</strong>。除<strong>终端元素</strong>以外，每个元素<strong>有一个或多个</strong>后续元素；除<strong>开始元素</strong>外，每个元素<strong>有且仅有一个</strong>前驱元素。</li>
</ul>
</li>
<li><p>图形结构</p>
<ul>
<li>元素之间关系是<strong>多对多</strong>的，所有元素都可能有<strong>多个</strong>前驱元素和多个后继元素。</li>
</ul>
</li>
<li><p>四类基本逻辑结构关系图：</p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221020163939195.png" alt="image-20221020163939195"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>存储结构或物理结构</strong></p>
<ul>
<li><strong>数据元素</strong>及其<strong>关系</strong>在计算机<strong>内存</strong>中的表示（又称<strong>映像</strong>），称为<strong>存储结构或物理结构</strong></li>
<li>是数据结构在<strong>计算机</strong>中的表现</li>
<li>四种基本的存储结构：<ul>
<li><strong>顺序存储结构</strong><ul>
<li>用<strong>一组连续的存储单元</strong>依次存储数据元素，数据元素之间的<strong>逻辑关系</strong>由元素的<strong>存储位置</strong>来表示</li>
<li><strong>逻辑</strong>上相邻的元素，<strong>物理</strong>上也相邻</li>
<li>C语言中用<strong>数组</strong>来实现顺序存储结构</li>
<li><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221020163959888.png" alt="image-20221020163959888"></li>
</ul>
</li>
<li><strong>链式存储结构</strong><ul>
<li>用<strong>一组任意的存储单元</strong>存储数据元素，一个逻辑元素用一个结点存储，每个结点单独分配，所有结点的地址<strong>不一定是连续</strong>的。用<strong>指针</strong>来表示逻辑关系。</li>
<li><strong>逻辑</strong>上相邻的元素，<strong>物理</strong>上<strong>可以不</strong>相邻</li>
<li><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221020164014365.png" alt="image-20221020164014365"></li>
<li><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221020164024165.png" alt="image-20221020164024165"></li>
</ul>
</li>
<li>索引存储结构<ul>
<li>在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址)</li>
</ul>
</li>
<li><strong>散列存储结构</strong><ul>
<li>根据元素的<strong>关键字</strong>直接<strong>计算</strong>出该元素的存储位置，又称哈希存储</li>
</ul>
</li>
<li>链式存储，索引存储，散列存储统称为<strong>非顺序存储</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据的运算和实现</strong></p>
<ul>
<li>对<strong>数据元素</strong>可以施加的<strong>操作</strong>以及这些操作在<strong>存储结构</strong>上的<strong>实现</strong></li>
<li>数据的运算包括：<strong>增删改查排</strong></li>
</ul>
</li>
</ul>
<h3 id="1-2-3-数据类型和抽象数据类型"><a href="#1-2-3-数据类型和抽象数据类型" class="headerlink" title="1.2.3 数据类型和抽象数据类型"></a>1.2.3 数据类型和抽象数据类型</h3><ul>
<li><p><strong>数据类型</strong></p>
<ul>
<li><p>数据类型是一组<strong>性质相同的值的集合</strong>和定义在这个值集上的一组<strong>操作</strong>的总称</p>
</li>
<li><p>即：数据类型&#x3D;值的集合+值集上的一组操作</p>
</li>
<li><p>例如：</p>
<ul>
<li>int,char, float, double等基本数据类型</li>
<li>数组、结构、共用体、枚举等构造数据类型</li>
<li>还有指针、空(void)类型</li>
<li>用户也可用typedef自己定义数据类型</li>
</ul>
</li>
<li><p>—些最基本<strong>数据结构</strong>可以用<strong>数据类型</strong>来实现，如<strong>数组</strong>、字符串等;</p>
</li>
<li><p>数据类型<strong>明显地或隐含地</strong>规定了在程序执行期间<strong>变量</strong>的所有可能的<strong>取值范围</strong>，以及在这些数值范围上所允许进行的<strong>操作</strong>。</p>
</li>
<li><p>数据类型可以分为<strong>原子类型</strong>和<strong>结构类型</strong></p>
<ul>
<li><p>原子类型其值<strong>不可再分</strong>（一种值的集合 + 定义在值集合上的一组操作）</p>
<ul>
<li>例如：int类型，就表示i是[-65536,65535]范围的整数，可以进行+、-、*、\、%等操作</li>
<li>bool类型，值的范围：true,false,可进行与,或,非的操作</li>
</ul>
</li>
<li><p><strong>结构类型</strong>其值<strong>可再分为若干成分</strong>（一种 <strong>数据结构</strong>（<strong>包括逻辑结构和物理结构）</strong> + 定义在这种数据结构上的一组操作）</p>
<ul>
<li><p>例如struct结构体数据类型:</p>
</li>
<li><p>&#96;&#96;&#96;c<br>struct Demo{<br>int x;&#x2F;&#x2F;分量1<br>int y;&#x2F;&#x2F;分量2<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **抽象数据类型（Abstract Data Type，ADT）**（理解即好）</span><br><span class="line"></span><br><span class="line">  - 是指一个**数学模型**以及定义在此数学模型上的一组**操作**。</span><br><span class="line"></span><br><span class="line">    - 由用户定义,从问题抽象出**数据模型**（**逻辑结构**)  </span><br><span class="line">    - 还包括定义在数据模型上的一组抽象运算(**相关操作**)（**算法**）</span><br><span class="line">    - 不考虑计算机内的具体**存储结构**与**运算的具体实现**</span><br><span class="line"></span><br><span class="line">  - **抽象数据类型=逻辑结构**(一组数据对象，及他们之间的关系)＋**相关操作**</span><br><span class="line"></span><br><span class="line">  - 抽象数据类型可用（D，S，P)三元组表示，D+S实际上 就是**数据结构**，P就是定义在这个数据结构上的操作集。</span><br><span class="line"></span><br><span class="line">  - 抽象数据类型的定义格式如下：</span><br><span class="line"></span><br><span class="line">    - ```c</span><br><span class="line">      ADT 抽象数据类型名&#123;</span><br><span class="line">         数据对象：〈数据对象的定义〉D</span><br><span class="line">         数据关系：〈数据关系的定义〉S  D+S为数学模型</span><br><span class="line">         基本操作：〈基本操作的定义〉P</span><br><span class="line">      &#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>基本操作的定义格式为:</p>
<ul>
<li>&#96;&#96;&#96;c<br>基本操作名（参数表）<br>   初始条件：〈初始条件描述〉<br>   操作结果：〈操作结果描述〉<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 抽象数据类型是描述数据结构的一种**理论**工具，其目的是使人们能够独立于程序的实现细节来理解数据结构的特性。</span><br><span class="line"></span><br><span class="line">- 总结</span><br><span class="line"></span><br><span class="line">  - ![image-20221020164042098](../img/数据结构与算法/image-20221020164042098.png)</span><br><span class="line"></span><br><span class="line">## 1.4 算法与算法分析</span><br><span class="line"></span><br><span class="line">- 较不同算法的时间效率，我们仅比较它们的**数量级**</span><br><span class="line">  - 例如：1000n^2时间效率好于2n^3</span><br><span class="line">- 若有某个**辅助函数f(n)**,使得当**n趋近于无穷大**时，T(n)/f(n)的极限值为**不等于零的常数**，则称f(n)是T(n)的**同数量级函数**。记作**T(n)=O(f(n)),**称O(f(n))为算法的**渐进时间复杂度**( O是数量级的符号)，简称**时间复杂度**</span><br><span class="line">- ![image-20221020164050670](../img/数据结构与算法/image-20221020164050670.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第二章 线性表</span><br><span class="line"></span><br><span class="line">## 2.1 线性表的定义和特点</span><br><span class="line"></span><br><span class="line">- **线性表**是具有**相同特性**的数据元素的一个**有限序列**</span><br><span class="line">- **同一线性表**中的元素**必定具有相同的特性**，即属于**同一数据对象**</span><br><span class="line">- 其特点是：</span><br><span class="line">  - **有且只有一个开始节点a1,他没有直接前驱，除a1外，结构中的每个数据元素均只有一个前驱。**</span><br><span class="line">  - **有且只有一个终端节点a2,他没有直接后继，除a2外，结构中的每个数据元素均只有一个后继。**</span><br><span class="line">- **线性表**是一种典型的**线性结构**</span><br><span class="line">- 我认为线性表**就是**线性结构（线性表又称线性结构）</span><br><span class="line"></span><br><span class="line">## 2.3 线性表的类型定义</span><br><span class="line"></span><br><span class="line">- 补充操作：</span><br><span class="line">- ***数组每个元素都是指针***</span><br><span class="line">- ![image-20221009124634379](E:\Blog\source\img\image-20221009124634379.png)</span><br><span class="line"></span><br><span class="line">- 线性表的抽象数据类型定义：</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  ADT List&#123;</span><br><span class="line">    数据对象：D=&#123;ai|ai∈ElemSet,i=1,2,…,n,n≥0&#125;</span><br><span class="line">    数据关系：R=&#123;&lt;ai-1,ai&gt;|ai-1,ai∈D,i=2,…,n&#125;</span><br><span class="line">    基本操作：</span><br><span class="line">      InitList(&amp;L)</span><br><span class="line">        操作结果：构造一个空的线性表L。</span><br><span class="line">      DestroyList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：销毁线性表L。</span><br><span class="line">      ClearList(&amp;L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：将L重置为空表。</span><br><span class="line">      ListEmpty(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若L为空表，则返回true，否则返回false。</span><br><span class="line">      ListLength(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：返回L中数据元素个数。</span><br><span class="line">      GetElem(L,i,&amp;e)</span><br><span class="line">        初始条件：线性表L已存在，且1≤i≤ListLength(L)。</span><br><span class="line">        操作结果：用e返回L中第i个数据元素的值。</span><br><span class="line">      LocateElem(L,e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。</span><br><span class="line">      PriorElem(L,cur_e,&amp;pre_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义。</span><br><span class="line">      NextElem(L,cur_e,&amp;next_e)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。</span><br><span class="line">      ListInsert(&amp;L,i,e)</span><br><span class="line">        初始条件：线性表L已存在，且1≤i≤ListLength(L)+1。</span><br><span class="line">        操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。</span><br><span class="line">      ListDelete(&amp;L,i)</span><br><span class="line">        初始条件：线性表L已存在且非空，且l≤i≤ListLength(L)。</span><br><span class="line">        操作结果：删除L的第i个数据元素，L的长度减1。</span><br><span class="line">      TraverseList(L)</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：对线性表L进行遍历，在遍历过程中对L的每个结点访问一次。</span><br><span class="line">  &#125;ADT List</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-线性表的顺序表示和实现"><a href="#2-4-线性表的顺序表示和实现" class="headerlink" title="2.4 线性表的顺序表示和实现"></a>2.4 线性表的顺序表示和实现</h2><h3 id="2-4-1-线性表的顺序存储表示"><a href="#2-4-1-线性表的顺序存储表示" class="headerlink" title="2.4.1 线性表的顺序存储表示"></a>2.4.1 线性表的顺序存储表示</h3><ul>
<li><p>线性表的顺序表示指的是<strong>用一组地址连续的存储单元依次存储线性表的数据元素</strong>（顺序表） </p>
</li>
<li><p>特点：<strong>逻辑上相邻</strong>的数据元素，其<strong>物理上也是相邻</strong>的。</p>
<p><img src="E:\Blog\source\img\image-20221009122409753.png" alt="image-20221009122409753"></p>
</li>
<li><p>依次存储，地址连续，<strong>中间没有空出的</strong></p>
</li>
<li><p>由此，只要确定了存储线性表的<strong>起始位置</strong>，线性表中任一数据元素都可<a target="_blank" rel="noopener" href="https://blog.csdn.net/agonie201218/article/details/123910423"><strong>随机存取</strong></a>，所以线性表的顺序存储结构是一种<strong>随机存取</strong>的存储结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- - - - - 顺序表的存储结构- - - - -</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100                     <span class="comment">//顺序表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">   ElemType *elem;                      <span class="comment">//存储空间的基地址</span></span><br><span class="line">   <span class="type">int</span> length;                          <span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;                                <span class="comment">//顺序表的结构类型为SqList</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-5-线性表的链式表示和实现"><a href="#2-5-线性表的链式表示和实现" class="headerlink" title="2.5 线性表的链式表示和实现"></a>2.5 线性表的链式表示和实现</h2><h3 id="2-5-1-单链表的定义和表示"><a href="#2-5-1-单链表的定义和表示" class="headerlink" title="2.5.1 单链表的定义和表示"></a>2.5.1 单链表的定义和表示</h3><ul>
<li><p>线性表链式存储结构的特点是：用一组<strong>任意的存储单元</strong>存储线性表的数据元素（这组存储单元<strong>可以是连续的，也可以是不连续的</strong>）</p>
</li>
<li><p>因此，为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需<strong>存储一个指示其直接后继的信息</strong>（即直接后继的存储位置）。这两部分信息组成数据元ai，称为<strong>结点（node）</strong>。它包括两个域：其中存<strong>储数据元素信息的域称为数据域</strong>；<strong>存储直接后继存储位置的域称为指针域</strong>。指针域中存储的信息称作<strong>指针或链</strong>。n个结点链结成一个链表，即为<strong>线性表</strong>的<strong>链式存储结构</strong></p>
</li>
<li><p>又由于此链表的每个结点中<strong>只包含一个指针域</strong>，故又称<strong>线性链表或单链表</strong></p>
</li>
<li><p><strong>双链表</strong>:每个结点有<strong>两个指针域</strong>；<strong>循环链表</strong>:链表<strong>结点首尾相接</strong></p>
</li>
<li><p>其中<strong>单链表、循环链表和双向链表用于实现线性表的链式存储结构</strong>，其他形式多用于<strong>实现树和图等非线性结构</strong>。</p>
</li>
<li><p>结点之间的<strong>箭头</strong>表示链域中的<strong>指针</strong></p>
</li>
<li><p><strong><img src="E:\Blog\source\img\image-20221005104918671.png" alt="image-20221005104918671"></strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;- - - - - 单链表的存储结构- - - - -<br>typedef struct  LNode<br>{<br>   ElemType  data;             &#x2F;&#x2F;结点的数据域<br>   struct LNode  *next;        &#x2F;&#x2F;结点的指针域<br>}LNode,*LinkList;         &#x2F;&#x2F;LinkList为指向结构体LNode的指针类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **首元结点**是指链表中存储**第一个数据元素a1**的结点。</span><br><span class="line"></span><br><span class="line">- **头结点**是在首元结点之前附设的一个结点,**是指向首元结点的结点**。（头结点的数据域可以不存储任何信息，也可存储与数据元素类型相同的其他附加信息。例如，当数据元素为整数型时，**头结点的数据域中可存放该线性表的长度。**）</span><br><span class="line"></span><br><span class="line">- **头指针**是指向**头结点**的指针，如下图，I为头指针</span><br><span class="line"></span><br><span class="line">- ![image-20221006112059427](E:\Blog\source\img\image-20221006112059427.png)</span><br><span class="line"></span><br><span class="line">- 无头结点时，**头指针为空时**表示空表</span><br><span class="line"></span><br><span class="line">- 有头结点时，**头结点的指针域为空时**表示空表</span><br><span class="line"></span><br><span class="line">### 2.5.2 单链表基本操作的实现</span><br><span class="line"></span><br><span class="line">#### 1．初始化</span><br><span class="line"></span><br><span class="line">- **生成新结点作为头结点，用头指针L指向头结点**。</span><br><span class="line"></span><br><span class="line">- 头结点的**指针域置空**。</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Status InitList(LinkList &amp;L)</span><br><span class="line">  &#123;//构造一个空的单链表L</span><br><span class="line">     L=new LNode;        //生成新结点作为头结点，用头指针L指向头结点</span><br><span class="line">     L-&gt;next=NULL;     //头结点的指针域置空</span><br><span class="line">     return OK;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-单链表的销毁"><a href="#2-单链表的销毁" class="headerlink" title="2.单链表的销毁"></a>2.单链表的销毁</h4><ul>
<li><p>从头指针开始，<strong>依次释放所有结点</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>Status InitList(LinkList &amp;L)<br>{&#x2F;&#x2F;销毁单链表L<br>Lode *p &#x2F;&#x2F;或LinlList p;<br>while(L){&#x2F;&#x2F;L不为NUll<br>p&#x3D;L;<br>L&#x3D;L-&gt;next;<br>delete p;<br>}<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.清空链表</span><br><span class="line"></span><br><span class="line">- 链表仍**存在**，但链表中**无元素**，成为空链表（**头指针和头结点仍然在**)也即是从**首元结点**开始销毁</span><br><span class="line">- 清空就相当于销毁**头结点后面的节点**</span><br><span class="line"></span><br><span class="line">#### 4.求单链表的表长</span><br><span class="line"></span><br><span class="line">- 算法思路：从**首元结点**开始，依次计数所有节点</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Status seqlistlength(LinkList L)&#123;</span><br><span class="line">  	LinkList p;</span><br><span class="line">  	int count=0;</span><br><span class="line">  	p=L-&gt;next;</span><br><span class="line">  	while(p)&#123;</span><br><span class="line">  		count++;//数量加一</span><br><span class="line">  		p=p-&gt;next;</span><br><span class="line">  	&#125;</span><br><span class="line">  	return count;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-取值–取单链表中第i个元素"><a href="#5-取值–取单链表中第i个元素" class="headerlink" title="5.取值–取单链表中第i个元素"></a>5.取值–取单链表中第i个元素</h4><ul>
<li><pre><code class="c++">Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123;
    p=L-&gt;next;
    int count=1;
    while(p&amp;&amp;count&lt;i)&#123;
    p=p-&gt;next;
    count++;
    &#125;
    if(!p||count &gt; i)
        return ERROR;
    e = p-&gt;data;
    return OK;
    &#125;
&#125; 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.按**值**查找——根据指定数据获取该数据**所在位置**</span><br><span class="line"></span><br><span class="line">- 找到后返回**地址**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">LinkList LocateElem_L(LinkList L,Elemtype e)&#123;</span><br><span class="line">    //找到返回地址，失败返回NULL</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    while(p &amp;&amp;p-&gt;data!=e)</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>找到后返回<strong>地址位置序号</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>int LocateElem_L(LinkList L,Elemtype e){<br>&#x2F;&#x2F;找到返回地址，失败返回NULL<br>p &#x3D; L-&gt;next;<br>count &#x3D; 1;<br>while(p&amp;&amp;p-&gt;data!&#x3D;e)<br>    {<br>    p &#x3D; p-&gt;next;<br>    count++<br>    }<br>if(p)<br>return count;<br>else<br>return 0;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7.插入--在第i个结点前插入值为e的新元素</span><br><span class="line"></span><br><span class="line">- 将值为x的新结点插入到表的**第i个结点**的位置上，即插入到**ai-1与ai之间**</span><br><span class="line"></span><br><span class="line">- ![image-20221009085511914](E:\Blog\source\img\image-20221009085511914.png)</span><br><span class="line"></span><br><span class="line">- **s-&gt;next=p-&gt;next;    p-&gt;next=s（两个步骤不可互换）**</span><br><span class="line"></span><br><span class="line">- 算法步骤 </span><br><span class="line"></span><br><span class="line">  - 找到**ai-1**存储位置p</span><br><span class="line">  - 生成一个新结点s</span><br><span class="line">  - 将新结点s的数据域置为x</span><br><span class="line">  - **新结点s的指针域指向结点ai**</span><br><span class="line">  - **令结点p的指针域指向新结点s**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Status ListInsert(LinkList &amp;L,int i,Elemtype e)&#123;</span><br><span class="line">  //先找到i-1的节点位置</span><br><span class="line">  p = L;//是为了方便在首元节点前插入xin&#x27;yaun&#x27;su</span><br><span class="line">  int count = 0;</span><br><span class="line">  while(p&amp;&amp;count&lt;i-1)&#123;</span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">  count++</span><br><span class="line">  &#125;</span><br><span class="line">      if(!p||count&gt;i-1);</span><br><span class="line">      return ERROR;</span><br><span class="line">  	s = new Lnode;</span><br><span class="line">    	s-&gt;next = x;</span><br><span class="line">      s-&gt;next = p-&gt;next;</span><br><span class="line">      p-&gt;next = s;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-删除（删除第-i-个结点）"><a href="#8-删除（删除第-i-个结点）" class="headerlink" title="8.删除（删除第 i 个结点）"></a>8.删除（删除第 i 个结点）</h4><ul>
<li><p><img src="E:\Blog\source\img\image-20221009085906054.png" alt="image-20221009085906054"></p>
</li>
<li><p>算法步骤 </p>
<ul>
<li>找到<strong>ai-1存储位置p</strong></li>
<li>临时保存结点<strong>ai的地址在q</strong>中，以备释放</li>
<li>令<strong>p-&gt;next指向ai的直接后继结点ai+1</strong></li>
<li>将ai的值保留在e中</li>
<li>释放ai的空间</li>
</ul>
</li>
<li><p>&#96;&#96;&#96;c++<br>&#x2F;&#x2F;将线性表L中第i个数据元素删除<br> Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)<br>{<br>p&#x3D;L;<br>j&#x3D;0;<br>while(p-&gt;next &amp;&amp;j&lt;i-1)&#x2F;&#x2F;这里判断条件是p-&gt;next是因为删除范围是(1~n)<br>{      &#x2F;&#x2F;寻找第i-1个结点,令p指向它<br>    p&#x3D;p-&gt;next;<br>    j++;<br>}<br>if(!(p-&gt;next)||j&gt;i-1)<br>    return ERROR; &#x2F;&#x2F;删除位置不合理<br>q&#x3D;p-&gt;next; &#x2F;&#x2F;临时保存被删结点的地址以备释放<br>p-&gt;next&#x3D;q-&gt;next;     &#x2F;&#x2F;改变删除结点前驱结点的指针域<br>e&#x3D;q-&gt;data;     &#x2F;&#x2F;保存删除结点的数据域<br>delete q;     &#x2F;&#x2F;释放删除结点的空间<br>return OK;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 9.单链表的建立（前插法）</span><br><span class="line"></span><br><span class="line">- 从一个空表开始，重复读入数据：</span><br><span class="line"></span><br><span class="line">  - 生成新结点</span><br><span class="line">  - 将读入数据存放到新结点的数据域中</span><br><span class="line">  - 从**最后一个节点**开始，一次将各节点插入到链表的**前端**</span><br><span class="line"></span><br><span class="line">- 插入方法是：将**头结点的指针域赋值给新节点的指针域**，再将**新节点赋值给头结点的指针域**</span><br><span class="line"></span><br><span class="line">- ![image-20221009091811772](E:\Blog\source\img\image-20221009091811772.png)</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void CreateList_F(LinkList &amp;L,int n)</span><br><span class="line">  &#123; </span><br><span class="line">       L=new LNode; </span><br><span class="line">       L-&gt;next=NULL; //先建立一个带头结点的单链表 </span><br><span class="line">       for(i=0;i&lt;n;i++)</span><br><span class="line">       &#123; </span><br><span class="line">          p=new LNode; //生成新结点 </span><br><span class="line">          cin&gt;&gt;p-&gt;data; //输入元素值 </span><br><span class="line">          p-&gt;next=L-&gt;next;</span><br><span class="line">          L-&gt;next=p; 	//插入到表头 </span><br><span class="line">       &#125; </span><br><span class="line">  &#125;//CreateList_F </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-单链表的建立（尾插法）"><a href="#10-单链表的建立（尾插法）" class="headerlink" title="10.单链表的建立（尾插法）"></a>10.单链表的建立（尾插法）</h4><ul>
<li><p>从一个空表L开始，将新结点逐个插入到链表的尾部，<strong>尾指针r始终指向链表的尾结点</strong>。</p>
</li>
<li><p>初始时，<strong>r同L均指向头结点</strong>。每读入一个数据元素则申请一个新结点，<strong>将新结点插入到尾结点后，r指向新结点。</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>void CreateList_L(LinkList &amp;L,int n)<br>{<br>  &#x2F;&#x2F;正位序输入n个元素的值，建立带表头结点的单链表L<br>  L&#x3D;new LNode;<br>  L-&gt;next&#x3D;NULL;<br>  r&#x3D;L;     &#x2F;&#x2F;尾指针r指向头结点<br>  for(i&#x3D;0;i&lt;n;++i)<br>  {<br>      p&#x3D;new LNode;    　    &#x2F;&#x2F;生成新结点<br>      cin&gt;&gt;p-&gt;data;           &#x2F;&#x2F;输入元素值<br>      p-&gt;next&#x3D;NULL;<br>      r-&gt;next&#x3D;p;       &#x2F;&#x2F;插入到表尾<br>      r&#x3D;p;     &#x2F;&#x2F;r指向新的尾结点<br>  }<br>}&#x2F;&#x2F;CreateList_L</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 11.代码实现</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//单链表的存储结构</span><br><span class="line">typedef struct LNode </span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"> </span><br><span class="line">// 单链表的初始化</span><br><span class="line">int InitList(LinkList &amp;L) </span><br><span class="line">&#123;</span><br><span class="line">	//构造一个空的单链表</span><br><span class="line">	L = new LNode;</span><br><span class="line">	L-&gt;next = NULL;</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//判断链表是否为空</span><br><span class="line">int ListEmpty(LinkList L) </span><br><span class="line">&#123;</span><br><span class="line">	if (L-&gt;next) </span><br><span class="line">	&#123;</span><br><span class="line">		return 0;    //非空 </span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		return 1;   //链表为空 </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//获取链表长度</span><br><span class="line">int ListLength(LinkList L) </span><br><span class="line">&#123;</span><br><span class="line">	int length = 0;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	</span><br><span class="line">	while (p) </span><br><span class="line">	&#123;</span><br><span class="line">		length++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return length;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历单链表</span><br><span class="line">void TraveList(LinkList L) </span><br><span class="line">&#123;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	printf(&quot;链表结果如下:\n&quot;);</span><br><span class="line">	</span><br><span class="line">	while (p) </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//查找</span><br><span class="line">//1.按序号查找</span><br><span class="line">int SelectByNo(LinkList L, int i, int &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">	//在带头结点的单链表中查找第i个值 </span><br><span class="line">	LNode *p;</span><br><span class="line">	p = L-&gt;next;      //  初始化，p指向第一个结点 </span><br><span class="line">	int j = 1;      // j用来计数</span><br><span class="line">	</span><br><span class="line">	while (p&amp;&amp;j &lt; i) </span><br><span class="line">	&#123;				   //顺着链域扫描，直到p指向第i个元素，或者p为空 </span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!p || j &gt; i) // i&gt;或者i&lt;1</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//2.按值查找</span><br><span class="line">LNode *SelectByValue(LinkList L, int e) </span><br><span class="line">&#123;</span><br><span class="line">	//在带头结点的单链表中查找值为e的元素</span><br><span class="line">	LNode *p;;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	</span><br><span class="line">	while (p&amp;&amp;p-&gt;data != e) </span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 插入操作</span><br><span class="line">int ListInsert(LinkList &amp;L, int i, int e)</span><br><span class="line">&#123;</span><br><span class="line">	//在单链表的第i个位置之前插入元素e</span><br><span class="line">	int j = 0;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = L;</span><br><span class="line">	</span><br><span class="line">	while (p&amp;&amp;j &lt; i - 1) </span><br><span class="line">	&#123;                 //寻找第i-1个结点 </span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!p || j &gt; i-1) </span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LNode *s;</span><br><span class="line">	s = new LNode;//生成新结点s</span><br><span class="line">	s-&gt;data = e; //将新结点的数据域置为e</span><br><span class="line">	s-&gt;next = p-&gt;next;//将新结点插入L中 </span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 删除操作</span><br><span class="line">int ListDelete(LinkList &amp;L, int i, int &amp;e) </span><br><span class="line">&#123;</span><br><span class="line">	//删除链表l中的第i个位置的元素，并用e返回其值</span><br><span class="line">	int j = 0;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = L;</span><br><span class="line">	</span><br><span class="line">	while (p-&gt;next&amp;&amp;j &lt; i - 1)// 寻找地i-1个结点 </span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!(p-&gt;next) || j &gt; i - 1) </span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LNode *q;</span><br><span class="line">	//q = new LNode;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	e = q-&gt;data;</span><br><span class="line">	</span><br><span class="line">	delete q;</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//前插法创建单链表</span><br><span class="line">void CreateList(LinkList &amp;L, int n)</span><br><span class="line">&#123;</span><br><span class="line">	//建立带头结点的单链表L,输入n个元素的值</span><br><span class="line">	L = new LNode;  // 先建立一个带头结点的空的单链表</span><br><span class="line">	L-&gt;next = NULL;</span><br><span class="line">	printf(&quot;输入n个元素的值:\n&quot;);</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		LNode *p;</span><br><span class="line">		p = new LNode;   // 生成新结点</span><br><span class="line">		printf(&quot;请输入第%d个元素的值:&quot;, i + 1);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;p-&gt;data);</span><br><span class="line">		// 插入</span><br><span class="line">		p-&gt;next = L-&gt;next;</span><br><span class="line">		L-&gt;next = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line"> </span><br><span class="line">	InitList(L);</span><br><span class="line">	if (ListEmpty(L)) </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表为空.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;链表非空.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	printf(&quot;请输入链表中元素的个数:\n&quot;);</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	CreateList(L, n);</span><br><span class="line"> </span><br><span class="line">	TraveList(L);</span><br><span class="line">	printf(&quot;当前链表长度是:%d\n&quot;, ListLength(L));</span><br><span class="line"> </span><br><span class="line">	printf(&quot;请输入要查找元素在链表中的位置:\n&quot;);</span><br><span class="line">	int location;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;location);</span><br><span class="line">	int e1;</span><br><span class="line">	if (SelectByNo(L, location, e1)) </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d位置元素的值是:%d\n&quot;, location, e1);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;查找失败!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	printf(&quot;输入要查找元素的值:\n&quot;);</span><br><span class="line">	int e2;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;e2);</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = SelectByValue(L, e2);</span><br><span class="line">	printf(&quot;位置:%p\n&quot;, p);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;请输入插入元素的位置和值:\n&quot;);</span><br><span class="line">	int e, location1;</span><br><span class="line">	scanf(&quot;%d,%d&quot;, &amp;location, &amp;e);</span><br><span class="line">	ListInsert(L, location, e);</span><br><span class="line">	TraveList(L);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;请输入要删除元素的位置:\n&quot;);</span><br><span class="line">	int location2;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;location2);</span><br><span class="line">	int e3;</span><br><span class="line">	ListDelete(L, location2, e3);</span><br><span class="line">	printf(&quot;要删除的元素值是:%d\n&quot;, e3);</span><br><span class="line">	TraveList(L);</span><br><span class="line"> </span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-3-循环链表"><a href="#2-5-3-循环链表" class="headerlink" title="2.5.3 循环链表"></a>2.5.3 循环链表</h3><ul>
<li><p>循环链表:是一种<strong>头尾相接</strong>的链表（表中最后一个结点的指针域<strong>指向头结点</strong>，整个链表<strong>形成一个环</strong>)</p>
</li>
<li><p><img src="E:\Blog\source\img\image-20221009102900025.png" alt="image-20221009102900025"></p>
</li>
<li><p><strong>尾指针指向</strong></p>
</li>
<li><p><img src="E:\Blog\source\img\image-20221009102936855.png" alt="image-20221009102936855"></p>
</li>
<li><p>带<strong>尾指针循环链表的合并</strong>(将Tb合并在Ta之后)</p>
</li>
<li><p><img src="E:\Blog\source\img\image-20221009103210082.png" alt="image-20221009103210082"></p>
</li>
<li><pre><code class="c++">LinkList Connect(LinkList Ta, LinkList
Tb)&#123;//假设Ta、Tb都是非空的单循环链表
p=Ta-&gt;next;//①p存表头结点
Ta-&gt;next=Tb-&gt;next-&gt;next//②Tb表头连结Ta表尾
delete Tb-&gt;next;//③释放Tb表头
Tb-&gt;next=p;//④修改指针
return Tb;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 2.5.4 双向链表</span><br><span class="line"></span><br><span class="line">#### 1.双向链表的插入</span><br><span class="line"></span><br><span class="line">- ![image-20221009095353337](E:\Blog\source\img\image-20221009095353337.png)</span><br><span class="line"></span><br><span class="line">- **1，2可换，3，4可换但前两个必须在前面**。**没有指针的结点总是需要先连接**</span><br><span class="line"></span><br><span class="line">#### 2.双向链表的删除</span><br><span class="line"></span><br><span class="line">- ![image-20221009095804889](E:\Blog\source\img\image-20221009095804889.png)</span><br><span class="line"></span><br><span class="line">#### 3.单链表、循环链表和双向链表的时间效率比较</span><br><span class="line"></span><br><span class="line">![image-20221009112227029](E:\Blog\source\img\image-20221009112227029.png)</span><br><span class="line"></span><br><span class="line">### 2.6 顺序表和链表的比较</span><br><span class="line"></span><br><span class="line">- 链式存储结构的**优点:**</span><br><span class="line">  - 结点空间可以**动态申请和释放**;</span><br><span class="line">  - 数据元素的逻辑次序靠**结点的指针来指示**，插入和删除时不需要移动数据元素。</span><br><span class="line">- 链式存储结构的**缺点:**</span><br><span class="line">  - 存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占字节不多时，**指针域所占存储空间的比重显得很大**。</span><br><span class="line">  - ![image-20221009113102170](E:\Blog\source\img\image-20221009113102170.png)</span><br><span class="line">- ![image-20221009113159450](E:\Blog\source\img\image-20221009113159450.png)</span><br><span class="line"></span><br><span class="line">### 2.7 线形表的应用</span><br><span class="line"></span><br><span class="line">- 线形表的合并</span><br><span class="line"></span><br><span class="line">- ![image-20221011212547250](E:\Blog\source\img\image-20221011212547250.png)</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void union(List &amp;La,List Lb)</span><br><span class="line">  &#123;</span><br><span class="line">  La_len=ListLength(La);</span><br><span class="line">  lb_len=ListLength(Lb);</span><br><span class="line">  for(i=1;i&lt;=Lb_len;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  GetElem(Lb,i,e);</span><br><span class="line">  if(LocateElem(La,e)) </span><br><span class="line">  ListInsert(&amp;La,++La_len,e);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>有序表的合并</p>
</li>
<li><p><img src="E:\Blog\source\img\image-20221011212627415.png" alt="image-20221011212627415"></p>
<ul>
<li><p>用<strong>顺序表</strong>实现</p>
</li>
<li><p>算法步骤：</p>
<ul>
<li>创建一个<strong>空表Lc</strong></li>
<li>依次从 La或 Lb中“摘取”元素值较小的结点插入到 Lc表的最后，<strong>直至其中一个表变空为止</strong></li>
<li>继续<strong>将La或Lb其中一个表的剩余结点插入在Lc表的最后</strong></li>
</ul>
</li>
<li><p><img src="E:\Blog\source\img\image-20221011213418108.png" alt="image-20221011213418108"></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>void MergeList_Sq(SqList LA,SqList LB,&amp;LC)<br>pa&#x3D;LA.elem;<br>pb&#x3D;LB.elem;&#x2F;&#x2F;指针pa和pb的初值分别指向两个表的第一个元素<br>LC.length&#x3D;LA.length+LB.length;&#x2F;&#x2F;新表长度为待合并两表的长度之和<br>LC.elem&#x3D;new ElemType[LC.length];&#x2F;&#x2F;为合并后的新表分配一个数组空间<br>pc&#x3D;LC.elem;&#x2F;&#x2F;指针pc指向新表的第一个元素<br>pa_last&#x3D;LA.elem+LA.length-1;&#x2F;&#x2F;指针pa_last指向LA表的最后一个元素<br>pb_last&#x3D;LB.elem+LB.length-1;&#x2F;&#x2F;指针pb_last指向LB表的最后一个元素<br>while(pa&lt;&#x3D;pa_last &amp;&amp; pb&lt;&#x3D;pb_last){&#x2F;&#x2F;两个表都非空,同一数组之间的指针可以比较大小<br>if(*pa&lt;&#x3D;*pb)<br>*pc++&#x3D;*pa++;&#x2F;&#x2F;依次“摘取”两表中值较小的结点<br>else *pc++&#x3D;*pb++;<br>}<br>while(pa&lt;&#x3D;pa_last)*pc++&#x3D;*pa++;&#x2F;&#x2F;LB表已到达表尾，将LA中剩余元素加入LC<br>while(pb&lt;&#x3D;pb_last)*pc++&#x3D;*pb++;&#x2F;&#x2F;LA表已到达表尾，将LB中剩余元素加入LC<br>}&#x2F;&#x2F;MergeList_Sq</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用**链表**实现</span><br><span class="line"></span><br><span class="line">- ![image-20221011214814148](E:\Blog\source\img\image-20221011214814148.png)</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  void MergeList_L(LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc)&#123;</span><br><span class="line">  pa=La-&gt;next; pb=Lb-&gt;next;</span><br><span class="line">  pc=Lc=La;//用La的头结点作为Lc的头结点</span><br><span class="line">  while(pa &amp;&amp; pb)&#123;//pa和pb链表都不为空</span><br><span class="line">  if(pa-&gt;data&lt;=pb-&gt;data) </span><br><span class="line">  &#123; </span><br><span class="line">  	pc-&gt;next=pa; </span><br><span class="line">  	pc=pa; </span><br><span class="line">  	pa=pa-&gt;next;&#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      pc-&gt;next=pb; </span><br><span class="line">      pc=pb;</span><br><span class="line">      pb=pb-&gt;next;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pc-&gt;next=pa?pa:pb;//插入剩余段</span><br><span class="line">  delete Lb;//释放Lb的头结点</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><ul>
<li>栈和队列也是<strong>线性表</strong>，其特殊性在于栈和队列的基本操作是<strong>线性表操作的子集</strong>，它们是<strong>操作受限的线性表</strong></li>
</ul>
<h2 id="3-1-栈和队列的定义和特点"><a href="#3-1-栈和队列的定义和特点" class="headerlink" title="3.1 栈和队列的定义和特点"></a>3.1 栈和队列的定义和特点</h2><h3 id="3-1-1-栈的定义和特点"><a href="#3-1-1-栈的定义和特点" class="headerlink" title="3.1.1 栈的定义和特点"></a>3.1.1 栈的定义和特点</h3><ul>
<li><strong>栈（stack）</strong>是限定仅在<strong>表尾</strong>进行插入或删除操作的<strong>线性表</strong>,栈又称为<strong>后进先出</strong>（Last In First Out，LIFO）的线性表</li>
<li><img src="E:\Blog\source\img\image-20221014155533090.png" alt="image-20221014155533090"></li>
</ul>
<h3 id="3-1-2-队列的定义和特点"><a href="#3-1-2-队列的定义和特点" class="headerlink" title="3.1.2 队列的定义和特点"></a>3.1.2 队列的定义和特点</h3><ul>
<li>和栈相反，<strong>队列（queue）</strong>是一种<strong>先进先出</strong>（First In First Out，FIFO）的线性表</li>
<li>它只允许在<strong>表的一端进行插入</strong>，而在<strong>另一端删除元素</strong>,这和日常生活中的排队是一致的.</li>
<li>在队列中，<strong>允许插入的一端称为队尾（rear），允许删除的一端则称为队头（front）</strong></li>
<li><img src="E:\Blog\source\img\image-20221014155852778.png" alt="image-20221014155852778"></li>
</ul>
<h2 id="3-3-栈的表示和操作的实现"><a href="#3-3-栈的表示和操作的实现" class="headerlink" title="3.3 栈的表示和操作的实现"></a>3.3 栈的表示和操作的实现</h2><h3 id="3-3-1-栈的类型定义"><a href="#3-3-1-栈的类型定义" class="headerlink" title="3.3.1 栈的类型定义"></a>3.3.1 栈的类型定义</h3><ul>
<li><p>栈的抽象数据类型定义：</p>
</li>
<li><p>&#96;&#96;&#96;<br>ADT Stack｛<br>  数据对象：D&#x3D;{ai|ai∈ElemSet,i&#x3D;1,2,…,n,n≥0}<br>  数据关系：R&#x3D;{&lt;ai-1,ai&gt;|ai-1,ai∈D,i&#x3D;2,…,n｝<br>        约定an端为栈顶，a1端为栈底。<br>  基本操作：<br>InitStack(&amp;S)<br>  操作结果：构造一个空栈S。<br>DestroyStack(&amp;S)<br>  初始条件：栈S已存在。<br>  操作结果：栈S被销毁。<br>ClearStack(&amp;S)<br>  初始条件：栈S已存在。<br>  操作结果：将S清为空栈。<br>StackEmpty(S)<br>  初始条件：栈S已存在。<br>  操作结果：若栈S为空栈，则返回true，否则返回false。<br>StackLength(S)<br>  初始条件：栈S已存在。<br>  操作结果：返回S的元素个数，即栈的长度。<br>GetTop(S)<br>  初始条件：栈S已存在且非空。<br>  操作结果：返回S的栈顶元素，不修改栈顶指针。<br>Push(&amp;S,e)<br>  初始条件：栈S已存在。<br>  操作结果：插入元素e为新的栈顶元素。<br>Pop(&amp;S,&amp;e)<br>  初始条件：栈S已存在且非空。<br>  操作结果：删除S的栈顶元素，并用e返回其值。<br>StackTraverse(S)<br>  初始条件：栈S已存在且非空。<br>  操作结果：从栈底到栈顶依次对S的每个数据元素进行访问。<br>}ADT Stack</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.3.2 顺序栈的表示和实现</span><br><span class="line"></span><br><span class="line">- **顺序栈**是指利用**顺序存储结构**实现的**栈**</span><br><span class="line">- **base为栈底指针**，初始化完成后，栈底指针base始终指向栈底的位置，若**base的值为NULL**，则表明**栈结构不存在**。**top为栈顶指针**，其**初值指向栈底**。每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1。因此，**栈空时，top和base的值相等**，都指向栈底；**栈非空时，top始终指向栈顶元素的上一个位置**。</span><br><span class="line">- stacksize指示栈可使用的**最大容量**，初始化操作为顺序栈动态分配MAXSIZE大小的数组空间，将stacksize置为MAXSIZE</span><br><span class="line">- ![image-20221014160745199](E:\Blog\source\img\image-20221014160745199.png)</span><br><span class="line"></span><br><span class="line">- **顺序栈**的定义如下：</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  //- - - - - 顺序栈的存储结构- - - - -</span><br><span class="line">  #define MAXSIZE 100             //顺序栈存储空间的初始分配量</span><br><span class="line">  typedef struct</span><br><span class="line">  &#123;</span><br><span class="line">     SElemType *base;             //栈底指针</span><br><span class="line">     SElemType *top;              //栈顶指针</span><br><span class="line">     int stacksize;               //栈可用的最大容量</span><br><span class="line">  &#125;SqStack；</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1．初始化"><a href="#1．初始化" class="headerlink" title="1．初始化"></a>1．初始化</h4><ul>
<li><p>顺序栈的初始化操作就是为顺序栈<strong>动态分配一个预定义大小的数组空间</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>Status InitStack(SqStack &amp;S)<br>{&#x2F;&#x2F;构造一个空栈S<br>   S.base&#x3D;new SElemType[MAXSIZE]；               &#x2F;&#x2F;为顺序栈动态分配一个最大容量为MAXSIZE的数组空间,使base指向这段空间的基地址，即栈底.<br>   if(!S.base) exit(OVERFLOW);                  &#x2F;&#x2F;若分配失败则s.base&#x3D;NULL，分配成功获得地址<br>   S.top&#x3D;S.base;                                &#x2F;&#x2F;top初始为base，空栈<br>   S.stacksize&#x3D;MAXSIZE;                         &#x2F;&#x2F;stacksize置为栈的最大容量MAXSIZE<br>   return OK;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 判断栈**是否为空**只需判断**S.top ==S.base是否为真**</span><br><span class="line"></span><br><span class="line">- 求**顺序栈长度**：**S.top -S.base**</span><br><span class="line"></span><br><span class="line">- **清空**顺序栈：只需**将top指针指向栈底**就可以，**if( S.base ) S.top = S.base**;</span><br><span class="line"></span><br><span class="line">#### 2. 销毁顺序栈</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">Status DestroyStack( SqStack &amp;S ) &#123;if( S.base ) &#123;</span><br><span class="line">delete S.base;//这里是动态内存释放问题，s.base所释放的是申请的动态内存，指针变量不会消失，动态内存释放后s.base此时是有地址的（随机的）要让s.base=null才可以</span><br><span class="line">S.stacksize = 0;</span><br><span class="line">S.base = S.top = NULL;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;顺序栈的**入栈**</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-顺序栈的入栈"><a href="#3-顺序栈的入栈" class="headerlink" title="3. 顺序栈的入栈"></a>3. 顺序栈的入栈</h4><ul>
<li><p>入栈操作是指在<strong>栈顶</strong>插入一个新的元素</p>
</li>
<li><p>&#96;&#96;&#96;c++<br>Status Push(SqStack &amp;S，SElemType e)<br>{&#x2F;&#x2F;插入元素e为新的栈顶元素<br>   if(S.top-S.base&#x3D;&#x3D;S.stacksize) return ERROR；         &#x2F;&#x2F;判断栈是否满，若满则返回ERROR<br>   *S.top++&#x3D;e；                                         &#x2F;&#x2F;元素e压入栈顶，栈顶指针加1<br>   return OK；<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 小贴士：*和++哪个优先级更高？</span><br><span class="line"></span><br><span class="line">- &gt; “*和++”两者**优先级相同**，需要按**从右到左**的顺序执行。其实这样只是当++在**变量前面的时候**才处理同一优先级,**当++在变量之后时**,你可以将++的优先级看成**最低级**的,比逗号运算符的优先级还低</span><br><span class="line"></span><br><span class="line">#### 4. 顺序栈的出栈</span><br><span class="line"></span><br><span class="line">- 出栈操作是将**栈顶元素删除**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  Status Pop(SqStack &amp;S,SElemType &amp;e)</span><br><span class="line">  &#123;删除S的栈顶元素，用e返回其值</span><br><span class="line">     if(S.top==S.base) return ERROR;              //判断栈是否空，若空则返回ERROR</span><br><span class="line">     e=*--S.top;                                  //栈顶指针减1，将栈顶元素赋给e</span><br><span class="line">     return OK;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5．取栈顶元素"><a href="#5．取栈顶元素" class="headerlink" title="5．取栈顶元素"></a>5．取栈顶元素</h4><ul>
<li><p>当<strong>栈非空</strong>时，此操作返回当前<strong>栈顶元素的值</strong>，<strong>栈顶指针保持不变</strong></p>
</li>
<li><p>&#96;&#96;&#96;c++<br>SElemType GetTop(SqStack S)<br>{&#x2F;&#x2F;返回S的栈顶元素，不修改栈顶指针<br>   if(S.top！&#x3D;S.base)                    &#x2F;&#x2F;栈非空<br>  return *(S.top-1);                &#x2F;&#x2F;返回栈顶元素的值，栈顶指针不变<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.3.3 链栈的表示和实现</span><br><span class="line"></span><br><span class="line">- 链栈是指采用**链式存储结构**实现的栈。通常链栈用**单链表**来表示，与单链表结构相同</span><br><span class="line"></span><br><span class="line">- **头指针**：是以确定线性表中**第一个元素**对应的存储位置，用于处理数组、链表、队列等数据结构。</span><br><span class="line"></span><br><span class="line">- 链栈中的指针是**指向尾部的头指针**，因为链栈中的**头指针**一直指向**栈顶**即**链表尾部**，且**没有头结点**，</span><br><span class="line"></span><br><span class="line">- 链栈的添加是**尾插法**</span><br><span class="line"></span><br><span class="line">- 基本**不存在栈满的情况**</span><br><span class="line"></span><br><span class="line">- 空栈相当于**头指针指向空**</span><br><span class="line"></span><br><span class="line">- 插入和删除仅在**栈顶**处执行</span><br><span class="line"></span><br><span class="line">- ![image-20221014172237820](E:\Blog\source\img\image-20221014172237820.png)</span><br><span class="line"></span><br><span class="line">- 链栈的**存储结构**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  //- - - - - 链栈的存储结构- - - - -</span><br><span class="line">  typedef struct StackNode//定义一个结构类型--栈的节点</span><br><span class="line">  &#123;</span><br><span class="line">     ElemType  data;//数据域</span><br><span class="line">     struct StackNode *next;//指针域</span><br><span class="line">  &#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-链栈的初始化"><a href="#1-链栈的初始化" class="headerlink" title="1.链栈的初始化"></a>1.链栈的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LinkStack initStack()&#123;</span><br><span class="line">    LinkStack S;</span><br><span class="line">    S=NULL;</span><br><span class="line">    return S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-判断链栈是否为空"><a href="#2-判断链栈是否为空" class="headerlink" title="2.判断链栈是否为空"></a>2.判断链栈是否为空</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status StackEmpty(LinkStack S)</span><br><span class="line">if (S==NULL) return TRUE;</span><br><span class="line">else return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-链栈的入栈"><a href="#3-链栈的入栈" class="headerlink" title="3.链栈的入栈"></a>3.链栈的入栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack&amp; S, SElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//在栈顶插入元素e,链栈不需要判断栈满</span></span><br><span class="line">	StackNode* p = <span class="keyword">new</span> StackNode;</span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = S;</span><br><span class="line">	S = p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-链栈的出栈"><a href="#3-链栈的出栈" class="headerlink" title="3.链栈的出栈"></a>3.链栈的出栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack&amp; S, SElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//删除S的栈顶元素，用e返回其值</span></span><br><span class="line">   <span class="keyword">if</span> (S == <span class="literal">NULL</span>)          <span class="comment">//判断是否为栈空</span></span><br><span class="line">      <span class="keyword">return</span> ERROR;</span><br><span class="line">   e = S-&gt;data;</span><br><span class="line">   StackNode* p = S;</span><br><span class="line">   S = S-&gt;next;</span><br><span class="line">   <span class="keyword">delete</span> p;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-取链栈的栈顶元素"><a href="#4-取链栈的栈顶元素" class="headerlink" title="4.取链栈的栈顶元素"></a>4.取链栈的栈顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S, SElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//返回S的栈顶元素，不修改栈顶指针</span></span><br><span class="line">   <span class="keyword">if</span> (S != <span class="literal">NULL</span>)    <span class="comment">//非栈空时返回</span></span><br><span class="line">      <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">   <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4栈和递归"><a href="#3-4栈和递归" class="headerlink" title="3.4栈和递归"></a>3.4栈和递归</h4><ul>
<li><p>递归算法是一种<strong>直接或者间接调用自身函数或者方法的算法</strong>。说简单了就是<strong>程序自身的调用</strong></p>
</li>
<li><p>递归算法就是将原问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解。（用同一个方法去解决规模不同的问题）</p>
</li>
<li><p>递归算法，顾名思义就是有两个大的阶段：<strong>递和归</strong>，即就是有<strong>去（递去）有回（归来）</strong></p>
</li>
<li><p>递去：将递归问题分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决</p>
</li>
<li><p>归来：当你将问题不断缩小规模递去的时候，必须有一个明确的<strong>结束递去的临界点（递归出口）</strong>，一旦达到这个临界点即就从该点<strong>原路返回到原点</strong>，最终问题得到解决。</p>
</li>
<li><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221020170807109.png" alt="image-20221020170807109"></p>
</li>
</ul>
<h2 id="3-5-队列的表示和操作的实现"><a href="#3-5-队列的表示和操作的实现" class="headerlink" title="3.5 队列的表示和操作的实现"></a>3.5 队列的表示和操作的实现</h2><h3 id="3-5-1-队列的类型定义"><a href="#3-5-1-队列的类型定义" class="headerlink" title="3.5.1 队列的类型定义"></a>3.5.1 队列的类型定义</h3><ul>
<li>队列<strong>插入在表尾</strong>插入，<strong>删除在表头</strong>删除，栈则是在<strong>表尾</strong>进行插入或删除</li>
</ul>
<h4 id="3-5-2-循环队列——队列的顺序表示和实现"><a href="#3-5-2-循环队列——队列的顺序表示和实现" class="headerlink" title="3.5.2 循环队列——队列的顺序表示和实现"></a>3.5.2 循环队列——队列的顺序表示和实现</h4><ul>
<li><p>在队列的顺序存储结构中，除了用一组<strong>地址连续的存储单元</strong>依次存放从队列头到队列尾的元素之外，尚需附设两个<strong>整型变量</strong>front和rear分别<strong>指示队列头元素及队列尾元素的位置</strong>（后面分别称为头指针和尾指针）。队列的顺序存储结构表示如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//- - - - - 队列的顺序存储结构- - - - -</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100            <span class="comment">//队列可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">   QElemType *base;             <span class="comment">//存储空间的基地址</span></span><br><span class="line">   <span class="type">int</span> front;                   <span class="comment">//头指针</span></span><br><span class="line">   <span class="type">int</span> rear;                    <span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221024143501965.png" alt="image-20221024143501965"></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031082649347.png" alt="image-20221031082649347"></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031082741924.png" alt="image-20221031082741924"></p>
<ul>
<li><strong>入队和出队</strong><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031092159554.png" alt="image-20221031092159554"></li>
<li><strong>入队</strong></li>
<li><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031092232480.png" alt="image-20221031092232480"></li>
<li><strong>出队</strong><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031092326548.png" alt="image-20221031092326548"></li>
<li><strong>取队头元素</strong><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031092454667.png" alt="image-20221031092454667"></li>
</ul>
<h4 id="3-5-3-循环队列——队列的链式表示和实现"><a href="#3-5-3-循环队列——队列的链式表示和实现" class="headerlink" title="3.5.3 循环队列——队列的链式表示和实现"></a>3.5.3 循环队列——队列的链式表示和实现</h4><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031093053959.png" alt="image-20221031093053959"></p>
<ul>
<li><em><strong>Qnode和QuenePtr</strong>都代表的只是指向这种</em><em>结点<strong>的</strong>指针*</em></li>
</ul>
<p><strong>销毁</strong></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031094116514.png" alt="image-20221031094116514"></p>
<p><strong>入队</strong></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031095200350.png" alt="image-20221031095200350"></p>
<p><strong>出队</strong></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031095304393.png" alt="image-20221031095304393"></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031095345346.png" alt="image-20221031095345346"></p>
<p><strong>求链队列的队头元索</strong></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031101217171.png" alt="image-20221031101217171"></p>
<h1 id="第4章串、数组和广义表"><a href="#第4章串、数组和广义表" class="headerlink" title="第4章串、数组和广义表"></a>第4章串、数组和广义表</h1><h2 id="4-1串的定义"><a href="#4-1串的定义" class="headerlink" title="4.1串的定义"></a>4.1串的定义</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031102816940.png" alt="image-20221031102816940"></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031103206796.png" alt="image-20221031103206796"></p>
<h2 id="4-3串的类型定义、存储结构及运算"><a href="#4-3串的类型定义、存储结构及运算" class="headerlink" title="4.3串的类型定义、存储结构及运算"></a>4.3串的类型定义、存储结构及运算</h2><p><strong>串的链式存储结构</strong></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031105128088.png" alt="image-20221031105128088"></p>
<p><strong>串的顺序存储结构</strong>（用的较多）</p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031105423531.png" alt="image-20221031105423531"></p>
<h3 id="4-3-3串的模式匹配算法"><a href="#4-3-3串的模式匹配算法" class="headerlink" title="4.3.3串的模式匹配算法"></a>4.3.3串的模式匹配算法</h3><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031110319439.png" alt="image-20221031110319439"></p>
<p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221031114237090.png" alt="image-20221031114237090"></p>
<h2 id="4-2数组"><a href="#4-2数组" class="headerlink" title="4.2数组"></a>4.2数组</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221107211044971.png" alt="image-20221107211044971"></p>
<h2 id="4-4-特殊矩阵的压缩存储"><a href="#4-4-特殊矩阵的压缩存储" class="headerlink" title="4.4  特殊矩阵的压缩存储"></a>4.4  特殊矩阵的压缩存储</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20221108213226751.png" alt="image-20221108213226751"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Seawater</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://seawater-water.github.io/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://seawater-water.github.io/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://seawater-water.github.io" target="_blank">什么是灵魂自由</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/default_top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/01/%E5%8D%81%E6%9C%88%E9%9A%8F%E7%AC%94/"><img class="prev-cover" src="/./img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">十月随笔</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/15/%E4%B9%9D%E6%9C%88%E9%9A%8F%E7%AC%94/"><img class="next-cover" src="/./img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">九月随笔</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/ave.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Seawater</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/seawater-water"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Walking alone under the fireworks..</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.1.</span> <span class="toc-text">1.2 基本概念和术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E6%95%B0%E6%8D%AE%E3%80%81%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E3%80%81%E6%95%B0%E6%8D%AE%E9%A1%B9%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.2.1 数据、数据元素、数据项和数据对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2.2 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.2.3 数据类型和抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2.4 线性表的顺序表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.4.1 线性表的顺序存储表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">2.5 线性表的链式表示和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.5.1 单链表的定义和表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">2.单链表的销毁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%96%E5%80%BC%E2%80%93%E5%8F%96%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">5.取值–取单链表中第i个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%88%A0%E9%99%A4%EF%BC%88%E5%88%A0%E9%99%A4%E7%AC%AC-i-%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">8.删除（删除第 i 个结点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%88%E5%B0%BE%E6%8F%92%E6%B3%95%EF%BC%89"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">10.单链表的建立（尾插法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.5.3 循环链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">第三章 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 栈和队列的定义和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1.1 栈的定义和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.1.2 队列的定义和特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">3.3 栈的表示和操作的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A0%88%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">3.3.1 栈的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1．初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">3. 顺序栈的入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%8E%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">5．取栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%93%BE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">1.链栈的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E9%93%BE%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">2.判断链栈是否为空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">3.链栈的入栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E6%A0%88%E7%9A%84%E5%87%BA%E6%A0%88"><span class="toc-number">2.2.1.7.</span> <span class="toc-text">3.链栈的出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8F%96%E9%93%BE%E6%A0%88%E7%9A%84%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.8.</span> <span class="toc-text">4.取链栈的栈顶元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E6%A0%88%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-number">2.2.1.9.</span> <span class="toc-text">3.4栈和递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.5 队列的表示和操作的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.5.1 队列的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">3.5.2 循环队列——队列的顺序表示和实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E2%80%94%E2%80%94%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">3.5.3 循环队列——队列的链式表示和实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">第4章串、数组和广义表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">4.1串的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E3%80%81%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">4.3串的类型定义、存储结构及运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">4.3.3串的模式匹配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">4.2数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.4.</span> <span class="toc-text">4.4  特殊矩阵的压缩存储</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/28/%E9%AB%98%E6%95%B0%E8%8B%8F%E5%BE%B7%E7%9F%BF/" title="高数苏德矿"><img src="/./img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高数苏德矿"/></a><div class="content"><a class="title" href="/2022/12/28/%E9%AB%98%E6%95%B0%E8%8B%8F%E5%BE%B7%E7%9F%BF/" title="高数苏德矿">高数苏德矿</a><time datetime="2022-12-28T04:06:31.000Z" title="发表于 2022-12-28 12:06:31">2022-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/%E5%8D%81%E4%B8%80%E6%9C%88%E8%AE%B0/" title="十一月记"><img src="/./img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十一月记"/></a><div class="content"><a class="title" href="/2022/11/01/%E5%8D%81%E4%B8%80%E6%9C%88%E8%AE%B0/" title="十一月记">十一月记</a><time datetime="2022-11-01T12:53:47.000Z" title="发表于 2022-11-01 20:53:47">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/15/Leetcode%E7%AC%94%E8%AE%B0/" title="Leetcode笔记"><img src="/./img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode笔记"/></a><div class="content"><a class="title" href="/2022/10/15/Leetcode%E7%AC%94%E8%AE%B0/" title="Leetcode笔记">Leetcode笔记</a><time datetime="2022-10-15T04:36:19.000Z" title="发表于 2022-10-15 12:36:19">2022-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/01/%E5%8D%81%E6%9C%88%E9%9A%8F%E7%AC%94/" title="十月随笔"><img src="/./img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="十月随笔"/></a><div class="content"><a class="title" href="/2022/10/01/%E5%8D%81%E6%9C%88%E9%9A%8F%E7%AC%94/" title="十月随笔">十月随笔</a><time datetime="2022-10-01T12:15:48.000Z" title="发表于 2022-10-01 20:15:48">2022-10-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img src="/./img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法">数据结构与算法</a><time datetime="2022-09-18T02:41:18.000Z" title="发表于 2022-09-18 10:41:18">2022-09-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: -#287091"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Seawater</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>